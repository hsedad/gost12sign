using System.Numerics;


namespace gost12sign
{
    internal class Init
    {
        internal BigInteger p, q, a, b, x, y, d; // коэффициенты эллиптической кривой, координаты начальной точки и цифровая подпись d
        //internal Point P0; // исходная точка P0

        public Init() { } // пустой конструктор для отладки методов
//---------------------------------------------------------------------------------------------------------------------------
        public Init(int length) // генерация начальных переменных
        {
            int Rounds = 32; // количество раундов теста Миллера-Рабина на простоту числа
            int Invar = 1696; // 1664, 1696, 1712, 1720, 1724, 1726, 1727 - удобные значения инварианта
            q = NextPrime(length - (length / 128), Rounds); // генерируем простое число 2^254<q<2^256 или 2^508<q<2^512
            p = GenP(q, length, Rounds); // генерация числа p - модуля эллиптической кривой (исходя из значения q)
            d = GenD(q, p); // генерация ключа подписи d
            GenAB(Invar); // вычисляем коэффициенты кривой по известному инварианту
            Point P0 = SetPointP(); // определяем начальную точку P0
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger GenD(BigInteger q, BigInteger p) // функция генерации число вычет (модуль p) меньше q
        {
            BigInteger res;
            do
                res = GenBigInteger((int)q.GetBitLength()); // генерируем число длиной бит числа q
            while ((res >= q) || (Legendre(res, p) > 1)); // если полученное число больше или равно q генерируем другое число
            return res; // возвращаем результат
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger NextPrime(int length, int mr) // метод, который выбирает простое число, используя последующие
        {
            BigInteger result = GenBigInteger(length); // генерируем число заданной битовой длины
            if (result.IsEven) result--; // если число четное, то уменьшаем его на 1
            while (!IsPrime(result, mr))  // запускаем цикл с проверкой на простоту
            {
                result += 2; //добавляем к числу 2 пока не получим простое число
            }
            return result; //возвращаем результат
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger PrevPrime(BigInteger n, int mr) // метод, который выбирает простое число, используя предыдущие
        {
            BigInteger result = n; // берем исходное число
            if (result.IsEven) result--; // если число четное, то уменьшаем его на 1
            while (!IsPrime(result, mr))  // запускаем цикл с проверкой на простоту
            {
                result -= 2; // вычитаем 2 пока не получим простое число
            }
            return result; //возвращаем результат
        }
//---------------------------------------------------------------------------------------------------------------------------
        public void GenAB(int iv) // процедура вычисляет значение коэффициентов a и b эллиптической кривой по известному инварианту
        {
            BigInteger k = iv/(1728 -iv); // получаем множитель k
            k = GetReverse(k, this.p); // обратный к iv/(1728 - iv) по модулю p
            this.a = GetReverse(3 * k, this.p); // получаем а
            this.b = GetReverse(2 * k, this.p); // получаем b
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger GenBigInteger(int length) // метод, который создает случайное число заданной длиной бит
               {
                   if (length < 1) return BigInteger.Zero; // рассматриваем даже нулевые значения
                   int bytes_len = (length / 8); // число байт в числе без учета числа бит в голове
                   int bits_len = (length % 8); // остаток бит 
                   Random rnd = new Random(); // клас генерации случайных чисел
                   byte[] bytes = new byte[bytes_len + 1]; // создаем массив байт
                   rnd.NextBytes(bytes); // заполняем массив байт случайными значениями
                   byte mask = (byte)(0xFF >> (8 - bits_len)); // создаем маску для выделения нужного числа бит в головном байте
                   bytes[bytes_len] &= mask; // применяем маску к головному байту
                   return new BigInteger(bytes); // преобразуем получившийся массив байт в большое число и возвращаем его
               }
//---------------------------------------------------------------------------------------------------------------------------
        public bool IsPrime(BigInteger n, int mr) // метод реализующий тест Миллера-Рабина на простоту числа с числом раундов k
        {
            if (n == 2 || n == 3) // проверяем число на 2 и 3 
                return true;
            if (n < 2 || n % 2 == 0) // проверяем число на 1 и четность
                return false;

            BigInteger d = n - 1; // число d в тесте Миллера-Рабина
            int s = 0; // показатель 2 в тесте 

            while (d % 2 == 0) // ищем числа d и s
            {
                d /= 2;
                s += 1;
            }

            BigInteger a;
            for (int i = 0; i < mr; i++) // цикл A теста Миллера-Рабина
            {
                do
                    a = GenBigInteger((int)n.GetBitLength()); // генерируем число a 
                while (a < 2 || a >= n - 2); // пока не получим a<2 или a>=n-2

                BigInteger x = BigInteger.ModPow(a, d, n); // получаем x = a^d(mod n)
                if (x == 1 || x == n - 1) continue; // проверяем x и в случае равенства переходим к следующему шагу цикла А

                for (int r = 1; r < s; r++) // цикл B теста Миллера-Рабина
                {
                    x = BigInteger.ModPow(x, 2, n); // вычисляем x <- x^2 (mod n)
                    if (x == 1)
                        return false; // если ==1 то число составное
                    if (x == n - 1) break; // если равно n-1 то перейти на следующий шаг цикла А
                }
                if (x != n - 1) return false; // если не равно n-1 то число составное
            }
            return true; // если прошли все проверки, то число с вероятностью 4^(-k) простое
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger Legendre(BigInteger a, BigInteger p) // функция вычисляет символ Лежандра
        {  
            return BigInteger.ModPow(a, (p-1)/2, p); // критерий Эйлера (a/p) = a^((p-1)/2)(mod p)
        }
//---------------------------------------------------------------------------------------------------------------------------   
        public BigInteger Sqrt(BigInteger bi) // функция возвращает квадратный корень из большого числа
        {
            BigInteger n = 0; BigInteger p = 0; // промежуточные значения p,n
            if (bi == 0) return 0; // корень из 0 0
            if (bi == 4) return 2; // осуществляя сдвиг вправо теряем значение для корня из 4
            BigInteger high = bi >> 1; // старшее число равно половине исходного числа
            BigInteger low = 0; // младшее число 0
            while (high > (low + 1)) // запускаем цикл, пока старшее и младшее число не сравняются
            {
                n = (high + low) >> 1; // сумму чисел делим на два
                p = n * n; // и возводим в квадрат
                if (bi < p) high = n; // проверяем, проскочили ли исходное число, меняем старшее число
                else
                {
                    if (bi > p) low = n; // или приблизились к исходному числу, меняем младшее число
                    else return n; // bi == p, квадрат n равен исходному числу, возвращаем n
                }
            }
            return low; // возвращаем low
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger SqrtMod(BigInteger a, BigInteger p) // функция возвращает квадратный корень числа a по модулю p
        {
            BigInteger b, d;
            do { b = GenBigInteger((int)p.GetBitLength()); } // генерируем целое число b
            while (Legendre(b,p) == 1); // которое является квадратичным невычетом по модулю p
            int s = 0; // показатель степени при разложении числк к виду 2^s*t
            BigInteger t = p - 1; // начальное значение числа t (неразложенное)
            while ((t & 1) != 1) { s++; t = t >> 1; } // сдвигаем число вправо, пока не станет нечетным 
            BigInteger ra = GetReverse(a, p); // вычисляем обратный элемент исходного числа a
            BigInteger c = BigInteger.ModPow(b, t, p); // вычисляем c = b ^ t % p
            BigInteger r = BigInteger.ModPow(a, (t+1)/2, p); // вычисляем r = a ^ ((t+1)/2) % p
            for (int i = 1; i < s; i++) // запускаем цикл
            {
                BigInteger temp = 2; // начальное значение показателя степени 2 - потом будет (s - i - 1) 
                temp = BigInteger.ModPow(temp, (s - i - 1), p); // вычисляем показатель степени 2 
                d = BigInteger.ModPow((BigInteger.ModPow(r, 2, p) * ra), temp, p); // вычисляем значение d=((r^2*ra)^(2^(s-i-1))%p
                if (d == (p - 1)) r = (r * c) % p; // если d равен p - 1 то пересчитываем r
                c = BigInteger.ModPow(c, 2, p); // возводим с в квадрат
            }
            return r; // возвращаем положительное значение r
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger GetReverse(BigInteger n, BigInteger m) // функция возвращает обратный элемент от n по модулю m
                                                                 // (m >= n > 0) используя расширенный алгоритм Евклида
        {
            BigInteger x, y, x1, x2, y1, y2, a, b, q, r;
            x1 = 0; y1 = 1; x2 = 1; y2 = 0; a = m; b = n;
            if (b == 0) return BigInteger.Zero;
            while (b > 0)
            {
                q = a / b; r = a - q * b; x = x2 - q * x1; y = y2 - q * y1;
                a = b; b = r; x2 = x1; x1 = x; y2 = y1; y1 = y;
            }
            if (y2 < 0) y2 = y2 + m;
            return y2;
        }
//---------------------------------------------------------------------------------------------------------------------------
        public BigInteger GenP(BigInteger q, int length, int rm) // функция производит генерацию числа p (модуль эллиптической кривой) из q
        {
            BigInteger low, high, res, m; // low = (sqrt(m)-1)^2 high = (sqrt(m)+1)^2
            BigInteger n = 65537; // множитель n для m = n * q
            do
            {
                m = q * n; n++; // получаем значение m, инкременируем n для возможного следующего шага
                low = (Sqrt(m) - 1) * (Sqrt(m) - 1); // минимальное значение p
                high = (Sqrt(m) + 1) * (Sqrt(m) + 1); // максимальное значение p
                res = PrevPrime(high, rm); // простое число p, меньшее максимального значения 
            }
            while 
            (!CheckP(res , q, length) || (res < low) || (res == m) || (Legendre(q, res) > 1)); // проверяем значение p на допустимость, если нет увеличиваем n
            return res; // возвращаем результат
        }
//---------------------------------------------------------------------------------------------------------------------------
        public bool CheckP(BigInteger p, BigInteger q, int length) // фукция проверки условия p^t != 1(mod q) для t= 1..31 или t= 1..131
        {
            int t = 31; // если параметр подписи 256 бит, то k=31
            if (length == 512) t = 131; // если параметр подписи 512 бит, то k=131
            bool result = true; // результат проверки
            for (int i = 1; i <= t; i++)
            {
              if (BigInteger.ModPow(p, i, q) == 1) result = false; // проверяем, если есть равенство, проверка не пройдена
            }
            return result; // возвращаем результат
        }
//---------------------------------------------------------------------------------------------------------------------------
        public Point SetPointP() // процедура задает начальную точку P
        {
            BigInteger x, y, y2; // значения координат x, y и y^2
            x = -(this.p - 1 / 2) ; // высчитываем x = -(p - 1)/2
            y2 = (x*x*x + this.a * x + this.b) % this.p; // находим y^2 значения функции
            y = SqrtMod(y2, this.p); // вычисляем квадратный корень, координата y
            this.x = x; this.y = y; // устанавливаем координаты
            return new Point(x, y, this.a, this.b, this.p); // заносим полученные координаты x и y в точку
        }                                                  
    }
}
